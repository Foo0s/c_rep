#include <iostream>
#include "many.h"
using namespace std;
int main()
{
    setlocale(LC_ALL, "RU");
    srand(time(NULL));

    Many tg1(4, 3, 4); // конструктор с параметрами

    // заполнение множества
    for (int ix = 0; ix < tg1.getSizeMany(); ix++)
        for (int jx = 0; jx < tg1.getSizeRow(); jx++)
            for (int zx = 0; zx < tg1.getSizeCol(); zx++)
                tg1[ix][jx][zx] = rand() % 100;

    cout << "перегруженный оператор вывода:\n" << tg1; // перегруженный оператор вывода

    Many tg2(tg1); // конструктор копирования
    cout << "Конструктор копирования Many tg2(tg1);:\n" << tg2;

    //    cin >> tg2; // перегруженный оператор ввода
    cout << "Вывод множества с помощщью метода класса Many\n";
    tg2.getMany(); // вывод множества с помощщью метода класса Many
    //    tg2.setMany(); // заполнение множества с помощщью метода класса Many
    //    cout << tg2;
    Many tg3 = tg2; // перегруженный оператор присваивания (коснтруктор по умолчанию)

    cout << "Перегруженный оператор присваивания Many tg3 = tg2;\n" << tg3;

    if (tg3 == tg2)
        cout << "Множества tg3 и tg2 равны!\n";
    cout << "Удаление всех элементов множества tg2\n" << -(-(-(-tg2))); // перегруженный оператор минус (удаление последнего элемента множества)

    cout << "Разность множеств (tg3 - tg3)\n" << (tg3 - tg3); // перегруженная операция минус (разность множеств)

    cout << "Объединение множеств: (tg3 + tg1)\n" << (tg3 + tg1); // перегруженная операция плюс (объединение множеств)

    tg1 += tg3;
    cout << "Объединение множеств tg1 +=tg3;:\n" << tg1;

    Matrix mt1(3, 4);

    // заполнение матрицы mt1
    for (int ix = 0; ix < mt1.getSizeMat(); ix++)
        for (int jx = 0; jx < mt1.getPtr()->getSize(); jx++)
            mt1[ix][jx] = 1; // единичная матрица

    cout << "tg1 + mt1\n" << (tg1 + mt1); // добавление элемента типа Matrix к множеству типа Many

    (tg1 += mt1) += mt1; // перегрузка оператора сложение-присвоение

    cout << "Добавление элемента типа Matrix к множеству типа Many:\n" << tg1;

    return 0;
}
